// Generated by CoffeeScript 1.6.1
(function() {
  var Game, GameManager, GameRules, Player, clone, game,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  game = require('./game.js');

  GameRules = game.Rules;

  Player = game.Player;

  GameManager = (function() {

    GameManager.prototype.playerCopy = function(player) {
      var i, newDeck, newPlayer;
      newPlayer = clone(player);
      newDeck = [];
      i = player.deck.length;
      while (i--) {
        newDeck[i] = null;
      }
      newPlayer.deck = newDeck;
      return newPlayer;
    };

    function GameManager(io) {
      this.io = io;
      this.player1 = null;
      this.player2 = null;
      this._turnCount = 0;
    }

    GameManager.prototype.connect = function(socket, name) {
      var currentName, data, deck, hand, hiddenDeck, hiddenHand, i, key, opp1, opp2, p1, p2, val, _ref, _ref1;
      if (!this.player1) {
        deck = Player.generateDeck();
        hand = (function() {
          var _i, _ref, _results;
          _results = [];
          for (i = _i = 1, _ref = GameRules.handSize; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
            _results.push(deck.pop());
          }
          return _results;
        })();
        data = {
          turn: true,
          opponent: null,
          deck: deck,
          hand: hand,
          name: name
        };
        this.player1 = new Player(data, socket);
        this.current = this.player1;
        return "Waiting for Opponent";
      } else if (!this.player2) {
        deck = Player.generateDeck();
        hand = (function() {
          var _i, _ref, _results;
          _results = [];
          for (i = _i = 1, _ref = GameRules.handSize; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
            _results.push(deck.pop());
          }
          return _results;
        })();
        data = {
          turn: false,
          opponent: null,
          deck: deck,
          hand: hand,
          name: name
        };
        this.player2 = new Player(data, socket);
      } else {
        console.log("No more players");
        return "Room full";
      }
      hiddenDeck = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 1, _ref = this.player1.deck.length; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
          _results.push(null);
        }
        return _results;
      }).call(this);
      hiddenHand = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 1, _ref = GameRules.handSize; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
          _results.push(null);
        }
        return _results;
      })();
      p1 = {};
      p2 = {};
      _ref = this.player1;
      for (key in _ref) {
        val = _ref[key];
        if (key === "turn" || key === "hand" || key === "name") {
          p1[key] = val;
        }
      }
      p1.deck = hiddenDeck;
      _ref1 = this.player2;
      for (key in _ref1) {
        val = _ref1[key];
        if (key === "turn" || key === "hand" || key === "name") {
          p2[key] = val;
        }
      }
      p2.deck = hiddenDeck;
      opp1 = {
        turn: p1.turn,
        name: p1.name,
        deck: hiddenDeck,
        hand: hiddenHand
      };
      opp2 = {
        turn: p2.turn,
        name: p2.name,
        deck: hiddenDeck,
        hand: hiddenHand
      };
      this.player1.socket.emit('startGame', p1, opp2);
      this.player2.socket.emit('startGame', p2, opp1);
      this.player1.opponent = this.player2;
      this.player2.opponent = this.player1;
      this.current = this.player1;
      currentName = this.current.name;
      return this.io.sockets["in"](this.current.socket.room).emit('serverMessage', {
        msg: "" + currentName + " will play a card",
        turn: currentName
      });
    };

    GameManager.prototype.updateTurn = function() {
      var opp, oppName;
      this._turnCount++;
      if (this._turnCount < 4) {
        opp = this.current.opponent;
        oppName = opp.name;
        this.current.turn = false;
        opp.turn = true;
        this.io.sockets["in"](this.current.socket.room).emit('serverMessage', {
          msg: "" + oppName + " will play a card",
          turn: oppName
        });
        return this.current = this.current.opponent;
      } else if (this._turnCount === 4) {
        return this.io.sockets["in"](this.current.socket.room).emit('serverMessage', {
          msg: "" + this.current.name + " will play another card"
        });
      } else {
        this.current = this.current.opponent;
        this.current.turn = true;
        this.current.opponent.turn = false;
        this.io.sockets["in"](this.current.socket.room).emit('serverMessage', {
          msg: "Normal tours started.",
          turn: this.current.name
        });
        this.io.sockets["in"](this.current.socket.room).emit('serverMessage', {
          msg: "Turn: " + this.current.name + " Actions Left:3"
        });
        this.current.actionsLeft = 3;
        return this.updateTurn = function() {
          this.current.actionsLeft--;
          if (this.current.actionsLeft === 0) {
            opp = this.current.opponent;
            oppName = opp.name;
            this.current.turn = false;
            opp.turn = true;
            this.io.sockets["in"](this.current.socket.room).emit('serverMessage', {
              msg: "Turn: " + oppName + " Actions Left:3",
              turn: oppName
            });
            this.current = opp;
            return this.current.actionsLeft = 3;
          } else {
            return this.io.sockets["in"](this.current.socket.room).emit('serverMessage', {
              msg: "Actions Left:" + this.current.actionsLeft
            });
          }
        };
      }
    };

    GameManager.prototype.processAction = function(action, socket) {
      var attacker, attackerHits, defender, defenderHits, hits, i, oppMessage, oppPlayer, oppResponse, oppResult, playedCard, player, playerName, response, result, success, _i, _ref;
      player = socket.id === this.player1.socket.id ? this.player1 : this.player2;
      oppPlayer = player === this.player1 ? this.player2 : this.player1;
      oppResponse = {};
      response = {};
      if (!player.turn) {
        response = {
          valid: false,
          message: "It is not your turn"
        };
      } else if (this._turnCount <= 4 && action.type !== "play") {
        response = {
          valid: false,
          message: "During setup tour you can only play a card."
        };
      } else if (player.checkAction(action)) {
        oppResponse.valid = response.valid = true;
        playerName = player.name;
        switch (action.type) {
          case 'draw':
            result = {
              card: player.deck[player.deck.length - 1]
            };
            oppResult = {
              card: null
            };
            oppMessage = playerName + " has drawn a card.";
            break;
          case 'attack':
            attacker = player.field[action.from];
            defender = oppPlayer.field[action.to];
            hits = [];
            success = attacker.attack / (attacker.attack + defender.defense);
            attackerHits = 1;
            defenderHits = 0;
            for (i = _i = 1, _ref = attacker.attack; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
              if (Math.random() < success) {
                hits.push(true);
                defenderHits++;
                if (defenderHits === defender.energy) {
                  break;
                }
              } else {
                hits.push(false);
              }
            }
            oppResult = result = {
              attackerHits: attackerHits,
              defenderHits: defenderHits,
              hits: hits
            };
            response.message = "" + playerName + "'s " + (attacker.toString()) + " attacking " + oppPlayer.name + "'s " + (defender.toString());
            oppMessage = response.message;
            break;
          case 'play':
            playedCard = player.hand[action.from];
            oppResult = {
              card: playedCard
            };
            oppMessage = playerName + " played " + playedCard.toString();
            break;
          case 'move':
            playedCard = player.field[action.from];
            oppMessage = playerName + " moved " + playedCard.toString();
            break;
          default:
            oppResult = result = {};
        }
        oppResponse.action = action;
        oppResponse.result = oppResult;
        oppResponse.message = oppMessage;
        oppPlayer.socket.emit('opponentAction', oppResponse);
        response.result = result;
        response.action = action;
        player.performAction(action, result);
      } else {
        response = {
          valid: false,
          message: "That action is not available to you currently"
        };
      }
      socket.emit('actionResult', response);
      if (response.valid) {
        return this.updateTurn();
      }
    };

    return GameManager;

  })();

  Game = (typeof exports !== "undefined" && exports !== null) && exports || (this.Game = {});

  Game.Manager = GameManager;

  clone = function(obj, skip) {
    var key, newInstance;
    if (skip == null) {
      skip = [];
    }
    if ((obj == null) || typeof obj !== 'object') {
      return obj;
    }
    if (obj instanceof Date) {
      return new Date(obj.getTime());
    }
    newInstance = new obj.constructor();
    for (key in obj) {
      if (__indexOf.call(skip, key) >= 0) {
        continue;
      }
      newInstance[key] = clone(obj[key]);
    }
    return newInstance;
  };

}).call(this);
