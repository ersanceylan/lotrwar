// Generated by CoffeeScript 1.6.1
(function() {
  var Game, GameManager, GameRules, Player, clone, game, p, q,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  game = require('./game.js');

  GameRules = game.Rules;

  Player = game.Player;

  GameManager = (function() {
    var hiddenHand, i, _i, _ref;

    for (i = _i = 0, _ref = GameRules.handSize; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      hiddenHand = null;
    }

    GameManager.prototype.playerCopy = function(player) {
      var newDeck, newPlayer;
      newPlayer = clone(player);
      newDeck = [];
      i = player.deck.length;
      while (i--) {
        newDeck[i] = null;
      }
      newPlayer.deck = newDeck;
      return newPlayer;
    };

    function GameManager(room) {
      this.room = room;
      this.player1 = null;
      this.player2 = null;
      this.current = this.player1;
    }

    GameManager.prototype.connect = function(socket, name) {
      var data, deck, hand, hiddenDeck, key, opp1, opp2, val, _j, _k, _l, _ref1, _ref2, _ref3, _ref4, _ref5;
      if (!this.player1) {
        deck = Player.generateDeck();
        for (i = _j = 1, _ref1 = GameRules.handSize; 1 <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = 1 <= _ref1 ? ++_j : --_j) {
          hand = deck.pop();
        }
        data = {
          turn: true,
          opponent: null,
          deck: deck,
          hand: hand
        };
        this.player1 = new Player(name, socket, data);
        return "Waiting for Opponent";
      } else if (!this.player2) {
        deck = Player.generateDeck();
        for (i = _k = 1, _ref2 = GameRules.handSize; 1 <= _ref2 ? _k <= _ref2 : _k >= _ref2; i = 1 <= _ref2 ? ++_k : --_k) {
          hand = deck.pop();
        }
        data = {
          turn: false,
          opponent: null,
          deck: deck,
          hand: hand
        };
        this.player2 = new Player(name, socket, data);
      } else {
        return "Room full";
      }
      for (i = _l = 1, _ref3 = this.player1.deck.length; 1 <= _ref3 ? _l <= _ref3 : _l >= _ref3; i = 1 <= _ref3 ? ++_l : --_l) {
        hiddenDeck = null;
      }
      _ref4 = this.player1;
      for (key in _ref4) {
        val = _ref4[key];
        if (key === "turn" || key === "hand") {
          p1[key] = val;
        }
      }
      p1.deck = hiddenDeck;
      _ref5 = this.player2;
      for (key in _ref5) {
        val = _ref5[key];
        if (key === "turn" || key === "hand") {
          p2[key] = val;
        }
      }
      p2.deck = hiddenDeck;
      opp1 = {
        turn: p1.turn,
        deck: hiddenDeck,
        hand: hiddenHand
      };
      opp2 = {
        turn: p2.turn,
        deck: hiddenDeck,
        hand: hiddenHand
      };
      this.player1.socket.emit('startGame', p1, opp2);
      return this.player2.socket.emit('startGame', p2, opp1);
    };

    GameManager.prototype.notifyAction = function(action, socket) {
      var oppPlayer, oppResult, player, response, result;
      player = socket === this.player1.socket ? this.player1 : this.player2;
      oppPlayer = player === this.player1 ? this.player2 : this.player1;
      response = {};
      if (player.checkAction(action)) {
        response.valid = true;
        switch (action.type) {
          case 'draw':
            result = {
              card: player.deck[player.deck.length - 1]
            };
            oppResult = {
              card: null
            };
            break;
          case 'attack':
            oppResult = result = {
              attackerHits: 1,
              defenderHits: 3
            };
            break;
          default:
            oppResult = result = {};
        }
        response.result = result;
        player.performAction(action, result);
        socket.emit('actionResult', response);
        response.action = action;
        response.result = oppResult;
        return oppPlayer.socket.emit('opponentAction', response);
      }
    };

    return GameManager;

  })();

  Game = (typeof exports !== "undefined" && exports !== null) && exports || (this.Game = {});

  Game.Manager = GameManager;

  p = new Player("izzet");

  q = new Player("ali");

  clone = function(obj, skip) {
    var key, newInstance;
    if (skip == null) {
      skip = [];
    }
    if ((obj == null) || typeof obj !== 'object') {
      return obj;
    }
    if (obj instanceof Date) {
      return new Date(obj.getTime());
    }
    newInstance = new obj.constructor();
    for (key in obj) {
      if (__indexOf.call(skip, key) >= 0) {
        continue;
      }
      newInstance[key] = clone(obj[key]);
    }
    return newInstance;
  };

}).call(this);
